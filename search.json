[
  {
    "objectID": "posts/002_zenido_primer/index.html",
    "href": "posts/002_zenido_primer/index.html",
    "title": "ZeniDo: Primer",
    "section": "",
    "text": "You’ve probably heard that ToDo apps are like the “Hello World” of web development. It seems like everyone has built one as part of their coding portfolio. But I haven’t!\nAs a data scientist and machine learning engineer, I’ve spent years crunching numbers and training AI models. Building a ToDo app? That’s a new world for me. So, I decided it’s time to step out of my comfort zone and join the ToDo app club. Better late than never, right?\nTo make things interesting, instead of showing a perfect, finished app, I want to take you along for the ride. You’ll see how I figure things out, make mistakes, and learn as I go.\nMy game plan:\n\nMake a quick app with full functionality to practice and see what works and what doesn’t work.\nReview the prototype, identify sensible abstractions and architectural decisions, and build sequence diagrams and some diagrams from C4 to inform the development.\nBuild it for real with scalability in mind.\n\nTech tools I plan to use for the prototype:\n\nFastAPI\nHTMX\nPostgres, Redis, and MongoDB\nNginx\nDocker\n\nI’m super excited to start this project and share everything I learn with you. Along the way, I’ll include optional materials, additional tasks, and questions for those who want to follow along and learn alongside me."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Posts",
    "section": "",
    "text": "GOATed resources for ML engineers: 1\n\n\n\n\n\n\nsoftware-engineering\n\n\nlearning-resources\n\n\ndata-science\n\n\nML\n\n\n\n\n\n\n\n\n\nOct 16, 2024\n\n\nZeniro\n\n\n\n\n\n\n\n\n\n\n\n\nZeniDo: Primer\n\n\n\n\n\n\nsoftware-engineering\n\n\ntodo-apps\n\n\n\n\n\n\n\n\n\nOct 13, 2024\n\n\nZeniro\n\n\n\n\n\n\n\n\n\n\n\n\nUsing HTMX with FastAPI\n\n\n\n\n\n\nfastapi\n\n\nhtmx\n\n\nshort-tutorials\n\n\n\n\n\n\n\n\n\nOct 12, 2024\n\n\nZeniro\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Hi, I am Zeniro!\nI am ML engineer. In this blog I want to share tutorials, notes, and projects on backend development and ML."
  },
  {
    "objectID": "posts/001_fastapi_htmx/index.html",
    "href": "posts/001_fastapi_htmx/index.html",
    "title": "Using HTMX with FastAPI",
    "section": "",
    "text": "I am planning to do a big project with FastAPI and HTMX soon. To prepare for this project I decided to create a short example on how to use HTMX with FastAPI.\nHTMX is a JavaScript library that allows to add interactivity to HTML without writing any JavaScript. It works by adding custom attributes to HTML elements, which trigger HTTP requests when events occur. HTMX then updates the page by swapping in the HTML returned by the server, making it incredibly easy to create dynamic, interactive web applications with minimal code.\nYou can find the repository for this project here.\nFirst, let’s install FastAPI and add Jinja2:\n# Create a virtual environment\npython -m venv .venv\nsource .venv/bin/activate\n\npip install \"fastapi[all]\" jinja2\nAlternatively, you can clone the repo and use it like this:\ngit clone https://github.com/zeniro-codes/tutorials.git\ncd tutorials/01_fastapi_htmx\n\npython -m venv .venv\nsource .venv/bin/activate\n\npip install -r requirements.txt\nNow that we have our environment set up, let’s create the main application file. Create a file named main.py and add the following code:\n\n\nmain.py\n\nfrom fastapi import FastAPI, Request\nfrom fastapi.templating import Jinja2Templates\nfrom fastapi.staticfiles import StaticFiles\nfrom fastapi.responses import HTMLResponse\n\n# Helps to render HTML templates located in the \"templates\" folder.\ntemplates = Jinja2Templates(directory=\"templates\")\n\napp = FastAPI(title=\"HTMX example\")\n\n# Makes files in the \"static\" directory accessible via the \"/static\" URL path.\n# It's crucial for serving our CSS and JavaScript files with Jinja2, see index.html\napp.mount(\"/static\", StaticFiles(directory=\"static\"), name=\"static\")\n\n# Renders the \"index.html\" template, passing the request object to the template.\n# The response_class=HTMLResponse tells FastAPI that this route returns HTML content.\n@app.get(\"/\", response_class=HTMLResponse)\ndef main(request: Request) -&gt; HTMLResponse:\n    return templates.TemplateResponse(request=request, name=\"index.html\")\n\n# Responds to GET requests at \"/click\".\n# When called (triggered by HTMX), it returns a simple HTML paragraph saying \"You clicked!\".\n# The underscore (_) for the parameter name indicates\n# that we're not using the request object in this function.\n@app.get(\"/click\", response_class=HTMLResponse)\ndef click(_: Request) -&gt; HTMLResponse:\n    return \"&lt;p&gt;You clicked!&lt;/p&gt;\"\n\nWe return HTMLResponse class because HTMX expects an HTML as a response.\nNext, let’s create our HTML template. Create a directory named templates and inside it, create a file named index.html. See comments for details on how it works:\n\n\ntemplates/index.html\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;Simple Page&lt;/title&gt;\n    &lt;!-- HTMX - https://htmx.org/ --&gt;\n    &lt;!-- \n    Jinja2 template syntax: {{ url_for('static', path='/js/htmx.js') }}\n    This generates the correct URL for our static files.\n    The 'defer' attribute ensures the script loads after the HTML is parsed.\n    Alternative, you can install by using the CDN: https://htmx.org/docs/#via-a-cdn-e-g-unpkg-com\n    --&gt;\n    &lt;script src=\"{{ url_for('static', path='/js/htmx.js') }}\" defer&gt;&lt;/script&gt;\n    &lt;!-- \n    Similarly, we use Jinja2 to generate the URL for our CSS file.\n    This ensures our static files are properly linked regardless of the server configuration.\n    --&gt;\n    &lt;link rel=\"stylesheet\" href=\"{{ url_for('static', path='/css/styles.css') }}\" /&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=\"container\"&gt;\n        &lt;h1&gt;Welcome to my simple page!&lt;/h1&gt;\n        &lt;!-- \n        HTMX attributes:\n        - hx-get=\"/click\": This tells HTMX to make a GET request to the \"/click\" endpoint when this button is clicked.\n        - hx-swap=\"outerHTML\": This instructs HTMX to replace the entire button element with the response from the server.\n        \n        When clicked, HTMX will send a request to our FastAPI backend, receive the response,\n        and replace this button with the content returned (in this case, \"You clicked!\").\n        --&gt;\n        &lt;button hx-get=\"/click\" hx-swap=\"outerHTML\"&gt;Click me!&lt;/button&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nThis setup allows for dynamic content updates without writing any custom JavaScript. When the button is clicked, HTMX sends a request to our FastAPI backend, receives the response (which is just the text “You clicked!”), and replaces the button with this new content.\nNow, let’s prepare the static directory. This directory will contain all our static files, including CSS and JavaScript. Here’s how to set it up:\n\nCreate a static directory in your project root.\nInside static, create two subdirectories: css and js.\nIn the css directory, create a file named styles.css and add your custom styles. You can take them from the provided repo.\nIn the js directory, we’ll add the HTMX library. You can take it from the provided repo.\n\nYour final project tree should resemble something like this:\n├── 01_fastapi_htmx\n│   ├── .venv\n│   ├── main.py\n│   ├── requirements.txt # might be omitted if you did not clone a tutorial\n│   ├── static\n│   │   ├── css\n│   │   │   └── styles.css\n│   │   └── js\n│   │       └── htmx.js\n│   └── templates\n│       └── index.html\nTo run the example, you can use this command in the root directory of the project:\nfastapi run main.py\nAnd if you open http://0.0.0.0:8000/, you can see the following result:\n\n\nMaterials\n\nRepo with example\nFastAPI tutorial on templates\nHTMX installation instruction"
  },
  {
    "objectID": "posts/003_learning_resources/index.html",
    "href": "posts/003_learning_resources/index.html",
    "title": "GOATed resources for ML engineers: 1",
    "section": "",
    "text": "This is the first blog post in a series on the learning resources that helped me become an ML engineer without a CS background. Here and in the next posts, I will include only the materials I worked with and that helped me in my daily job as an ML engineer. No affiliate links, just the stuff that helped me the most in my ML engineering career.\n\nDeep Dive into Python from Dr. Fred Baptiste. This series of courses takes roughly 100 hours to complete, but every second worths it. Your code quality will increase significantly, you will understand and appreciate Python on a whole different level. Some topics that were super helpful to me: memory, reference counting, and garbage collection in Python, Python data structures, and metaprogramming in Python. Dr. Fred also has an amazing YouTube channel on idiomatic Python, cool Python libraries, etc. If you finish these courses, there will not be a Python topic that you will not understand how to work with.\nTaking Python to Production: A Professional Onboarding Guide from Eric Riddoch. Eric created the best course on how to set up a development environment for your work with Python. You’ll learn how to make your terminal more intuitive with ZSH and plugins, version and package Python software, and set up automated code quality checks. But the best part of this course is that you will understand what is possible in setting up a development environment, and you can modify it easily. I use the knowledge from the course pretty much on a daily basis.\nFundamentals of Network Engineering and Fundamentals of Operating Systems from Hussein Nasser. You’ll gain an understanding of network protocols like TCP/IP, learn about the OSI model, and explore how operating systems manage processes and resources. The courses also cover practical skills like using Wireshark for traffic inspection and optimizing applications based on OS principles. This was an “unknown unknown” - something I didn’t even know that I didn’t know. Information from these courses helps me to build more scalable ML processes, and I come back to them quite often. Additionally, it might also help you better understand what ThePrimeagen talks about in his streams, so it’s worth it just because of this fact.\nEnd-to-End Machine Learning: From Idea to Implementation from Kıvanç Yüksel. This course covers the entire ML project lifecycle in a very thorough project. You’ll learn about data versioning, distributed processing and model training, and the principles of MLOps. The course also covers experiment tracking, error analysis, and creating applications using trained models. It is one of the best demonstrations of the machine learning engineer job in comparison to the data scientist job to date. Highly recommend."
  }
]